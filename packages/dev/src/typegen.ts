import { existsSync } from 'node:fs'
import { mkdir, readdir, readFile, writeFile } from 'node:fs/promises'
import { dirname, join, relative } from 'node:path'
import { Logger } from '@faasjs/logger'
import { loadConfig } from '@faasjs/node-utils'
import { resolveServerConfig } from './server_config'

type RouteTypeItem = {
  route: string
  importPath: string
  pluginTypes: string[]
  priority: number
}

export type GenerateFaasTypesOptions = {
  /** faas project root path, default is process.cwd() */
  root?: string
  /** optional logger instance */
  logger?: Logger
}

export type GenerateFaasTypesResult = {
  output: string
  changed: boolean
  fileCount: number
  routeCount: number
}

function normalizeSlashes(path: string): string {
  return path.replace(/\\/g, '/')
}

function normalizeRoute(path: string): string {
  const normalized = path.replace(/\/+/g, '/')

  if (!normalized.length || normalized === '/') return '/'

  return normalized.endsWith('/') ? normalized.slice(0, -1) : normalized
}

function toRoute(
  srcRoot: string,
  file: string
): { route: string; priority: number } {
  const relativePath = normalizeSlashes(relative(srcRoot, file))
  const noTsPath = relativePath.replace(/\.ts$/, '')

  if (noTsPath === 'index.func') return { route: '/', priority: 2 }

  if (noTsPath === 'default.func') return { route: '/*', priority: 1 }

  if (noTsPath.endsWith('/index.func'))
    return {
      route: normalizeRoute(`/${noTsPath.slice(0, -'/index.func'.length)}`),
      priority: 2,
    }

  if (noTsPath.endsWith('/default.func'))
    return {
      route: normalizeRoute(`/${noTsPath.slice(0, -'/default.func'.length)}/*`),
      priority: 1,
    }

  if (noTsPath.endsWith('.func'))
    return {
      route: normalizeRoute(`/${noTsPath.slice(0, -'.func'.length)}`),
      priority: 3,
    }

  throw Error(`[faas-types] Invalid func filename: ${file}`)
}

function toImportPath(fromFile: string, targetFile: string): string {
  const fromDir = dirname(fromFile)
  const importPath = normalizeSlashes(relative(fromDir, targetFile)).replace(
    /\.ts$/,
    ''
  )

  if (importPath.startsWith('.')) return importPath

  return `./${importPath}`
}

function parsePluginTypes(config: Record<string, any>): string[] {
  const pluginConfig = config.plugins

  if (!pluginConfig || typeof pluginConfig !== 'object') return []

  const pluginTypes = new Set<string>()

  for (const key in pluginConfig) {
    const data = pluginConfig[key]

    if (typeof data === 'string' && data.length) {
      pluginTypes.add(data)
      continue
    }

    if (data && typeof data === 'object') {
      if (typeof data.type === 'string' && data.type.length)
        pluginTypes.add(data.type)
      else pluginTypes.add(key)
      continue
    }

    pluginTypes.add(key)
  }

  return Array.from(pluginTypes).sort((a, b) => a.localeCompare(b))
}

async function readFuncFiles(dir: string): Promise<string[]> {
  const result: string[] = []

  async function walk(currentDir: string): Promise<void> {
    const entries = await readdir(currentDir, {
      withFileTypes: true,
    })

    for (const entry of entries) {
      if (entry.name === '.faasjs' || entry.name === 'node_modules') continue

      const filePath = join(currentDir, entry.name)

      if (entry.isDirectory()) {
        await walk(filePath)
        continue
      }

      if (entry.isFile() && entry.name.endsWith('.func.ts'))
        result.push(filePath)
    }
  }

  await walk(dir)

  return result.sort((a, b) => a.localeCompare(b))
}

function formatTypes(items: RouteTypeItem[]): string {
  const actionLines = items.map(item => {
    return `    ${JSON.stringify(item.route)}: __FaasFuncAction<__FaasModuleFunc<typeof import(${JSON.stringify(item.importPath)})>>`
  })

  const eventLines = items.map(item => {
    const plugins = item.pluginTypes.length
      ? `[${item.pluginTypes.map(type => JSON.stringify(type)).join(', ')}]`
      : '[]'

    return `    ${JSON.stringify(item.route)}: InferPluginEvent<${plugins}>`
  })

  return `/**
 * Generated by @faasjs/dev.
 *
 * Do not edit this file manually.
 */
import type { Func, InferPluginEvent } from '@faasjs/func'

type __FaasModuleFunc<TModule> = TModule extends { func: infer TFunc }
  ? TFunc extends Func
    ? TFunc
    : never
  : TModule extends { default: infer TFunc }
    ? TFunc extends Func
      ? TFunc
      : never
    : never

type __FaasFuncAction<TFunc extends Func> = {
  Params: Parameters<ReturnType<TFunc['export']>['handler']>[0]['params']
  Data: Awaited<ReturnType<ReturnType<TFunc['export']>['handler']>>
}

declare module '@faasjs/types' {
  interface FaasActions {
${actionLines.length ? `${actionLines.join('\n')}\n` : ''}  }

  interface FaasEvents {
${eventLines.length ? `${eventLines.join('\n')}\n` : ''}  }
}
`
}

export function isTypegenSourceFile(filePath: string): boolean {
  return /\.func\.ts$/.test(filePath) || /(^|[\\/])faas\.ya?ml$/.test(filePath)
}

export async function generateFaasTypes(
  options: GenerateFaasTypesOptions = {}
): Promise<GenerateFaasTypesResult> {
  const logger = options.logger || new Logger('FaasJs:Typegen')
  const { root: projectRoot, staging } = resolveServerConfig(
    options.root || process.cwd(),
    logger
  )
  const srcRoot = join(projectRoot, 'src')
  const output = join(srcRoot, '.faasjs', 'types.d.ts')

  if (!existsSync(srcRoot))
    throw Error(`[faas-types] Source directory not found: ${srcRoot}`)

  const files = await readFuncFiles(srcRoot)
  const routeMap = new Map<string, RouteTypeItem>()

  for (const file of files) {
    const { route, priority } = toRoute(srcRoot, file)
    const config = loadConfig(srcRoot, file, staging, logger)
    const pluginTypes = parsePluginTypes(config as Record<string, any>)
    const importPath = toImportPath(output, file)
    const prev = routeMap.get(route)

    if (!prev || priority > prev.priority)
      routeMap.set(route, {
        route,
        importPath,
        pluginTypes,
        priority,
      })
  }

  const items = Array.from(routeMap.values()).sort((a, b) =>
    a.route.localeCompare(b.route)
  )
  const content = formatTypes(items)

  let changed = true

  try {
    const previous = await readFile(output, 'utf8')

    if (previous === content) changed = false
  } catch (_error) {}

  if (changed) {
    await mkdir(dirname(output), {
      recursive: true,
    })
    await writeFile(output, content)
  }

  return {
    output,
    changed,
    fileCount: files.length,
    routeCount: items.length,
  }
}
