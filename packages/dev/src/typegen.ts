import { existsSync } from 'node:fs'
import { mkdir, readdir, readFile, writeFile } from 'node:fs/promises'
import { dirname, join, relative } from 'node:path'
import { Logger } from '@faasjs/logger'
import { loadConfig } from '@faasjs/node-utils'
import { resolveServerConfig } from './server_config'

type RouteTypeItem = {
  route: string
  importPath: string
  pluginTypes: string[]
  priority: number
}

export type GenerateFaasTypesOptions = {
  /** faas project root path, default is process.cwd() */
  root?: string
  /** optional logger instance */
  logger?: Logger
}

export type GenerateFaasTypesResult = {
  output: string
  changed: boolean
  fileCount: number
  routeCount: number
}

function normalizeRoute(path: string): string {
  const normalized = path.replace(/\\/g, '/').replace(/\/+/g, '/')

  if (!normalized.length || normalized === '/') return '/'

  return normalized.endsWith('/') ? normalized.slice(0, -1) : normalized
}

function toTypegenRoute(route: string): string {
  return route === '/' ? '/' : route.replace(/^\/+/, '')
}

function toRoute(
  srcRoot: string,
  file: string
): { route: string; priority: number } {
  const noTsPath = relative(srcRoot, file)
    .replace(/\\/g, '/')
    .replace(/\.ts$/, '')

  if (noTsPath === 'index.func') return { route: '/', priority: 2 }

  if (noTsPath === 'default.func') return { route: '/*', priority: 1 }

  if (noTsPath.endsWith('/index.func'))
    return {
      route: normalizeRoute(`/${noTsPath.slice(0, -'/index.func'.length)}`),
      priority: 2,
    }

  if (noTsPath.endsWith('/default.func'))
    return {
      route: normalizeRoute(`/${noTsPath.slice(0, -'/default.func'.length)}/*`),
      priority: 1,
    }

  if (noTsPath.endsWith('.func'))
    return {
      route: normalizeRoute(`/${noTsPath.slice(0, -'.func'.length)}`),
      priority: 3,
    }

  throw Error(`[faas types] Invalid func filename: ${file}`)
}

function toImportPath(fromFile: string, targetFile: string): string {
  const importPath = relative(dirname(fromFile), targetFile)
    .replace(/\\/g, '/')
    .replace(/\.ts$/, '')

  if (importPath.startsWith('.')) return importPath

  return `./${importPath}`
}

function parsePluginTypes(config: Record<string, any>): string[] {
  const pluginConfig = config.plugins

  if (!pluginConfig || typeof pluginConfig !== 'object') return []

  const pluginTypes = new Set<string>()

  for (const key in pluginConfig) {
    const data = pluginConfig[key]

    if (typeof data === 'string' && data.length) {
      pluginTypes.add(data)
      continue
    }

    if (data && typeof data === 'object') {
      if (typeof data.type === 'string' && data.type.length)
        pluginTypes.add(data.type)
      else pluginTypes.add(key)
      continue
    }

    pluginTypes.add(key)
  }

  return Array.from(pluginTypes).sort((a, b) => a.localeCompare(b))
}

async function readFuncFiles(dir: string): Promise<string[]> {
  const result: string[] = []
  const pendingDirs = [dir]

  while (pendingDirs.length) {
    const currentDir = pendingDirs.pop() as string
    const entries = await readdir(currentDir, {
      withFileTypes: true,
    })

    for (const entry of entries) {
      if (entry.name === '.faasjs' || entry.name === 'node_modules') continue

      const filePath = join(currentDir, entry.name)

      if (entry.isDirectory()) {
        pendingDirs.push(filePath)
        continue
      }

      if (entry.isFile() && entry.name.endsWith('.func.ts'))
        result.push(filePath)
    }
  }

  return result.sort((a, b) => a.localeCompare(b))
}

function formatTypes(items: RouteTypeItem[]): string {
  const actionLines = items.map(item => {
    return `    ${JSON.stringify(toTypegenRoute(item.route))}: InferFaasAction<InferFaasFunc<typeof import(${JSON.stringify(item.importPath)})>>`
  })

  const eventLines = items.map(item => {
    const plugins = item.pluginTypes.length
      ? `[${item.pluginTypes.map(type => JSON.stringify(type)).join(', ')}]`
      : '[]'

    return `    ${JSON.stringify(toTypegenRoute(item.route))}: InferPluginEvent<${plugins}>`
  })

  return `/**
 * Generated by @faasjs/dev.
 *
 * Do not edit this file manually.
 */
import type { Func, InferPluginEvent } from '@faasjs/func'
import type { InferFaasAction, InferFaasFunc } from '@faasjs/types'

declare module '@faasjs/types' {
  interface FaasActions {
${actionLines.length ? `${actionLines.join('\n')}\n` : ''}  }

  interface FaasEvents {
${eventLines.length ? `${eventLines.join('\n')}\n` : ''}  }
}
`
}

export function isTypegenSourceFile(filePath: string): boolean {
  return /\.func\.ts$/.test(filePath) || /(^|[\\/])faas\.ya?ml$/.test(filePath)
}

export async function generateFaasTypes(
  options: GenerateFaasTypesOptions = {}
): Promise<GenerateFaasTypesResult> {
  const logger = options.logger ?? new Logger('FaasJs:Typegen')
  const { root: projectRoot, staging } = resolveServerConfig(
    options.root ?? process.cwd(),
    logger
  )
  const srcRoot = join(projectRoot, 'src')
  const output = join(srcRoot, '.faasjs', 'types.d.ts')

  if (!existsSync(srcRoot))
    throw Error(`[faas types] Source directory not found: ${srcRoot}`)

  const files = await readFuncFiles(srcRoot)
  const routeMap = new Map<string, RouteTypeItem>()

  for (const file of files) {
    const { route, priority } = toRoute(srcRoot, file)
    const prev = routeMap.get(route)

    if (prev && priority <= prev.priority) continue

    routeMap.set(route, {
      route,
      importPath: toImportPath(output, file),
      pluginTypes: parsePluginTypes(
        loadConfig(srcRoot, file, staging, logger) as Record<string, any>
      ),
      priority,
    })
  }

  const items = Array.from(routeMap.values()).sort((a, b) =>
    a.route.localeCompare(b.route)
  )
  const content = formatTypes(items)

  let changed = true

  try {
    if ((await readFile(output, 'utf8')) === content) changed = false
  } catch {}

  if (changed) {
    await mkdir(dirname(output), {
      recursive: true,
    })
    await writeFile(output, content)
  }

  return {
    output,
    changed,
    fileCount: files.length,
    routeCount: items.length,
  }
}
